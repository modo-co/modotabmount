esphome:
  name: modotabmount
  friendly_name: Modo Tab Mount
  name_add_mac_suffix: true

  on_boot:
    priority: -100
    then:
      - if:
          condition:
            lambda: |-
              return !wifi::global_wifi_component->is_connected() &&
                     wifi::global_wifi_component->has_ap();
          then:
            - script.execute: led_ap_mode

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf
  variant: esp32c3

logger:

debug:
  update_interval: 10s

network:

api:

wifi:
  ap:
  on_connect:
    then:
      - script.execute: led_ap_mode_stop
      - script.execute: led_wifi_connected

captive_portal:

ota:
  - platform: esphome

web_server:
  port: 80
  version: 3
  log: false

bluetooth_proxy:
  active: true

i2c:
  sda: 7
  scl: 21
  scan: true

# --------------------------------------------------------------------
# Globals
# --------------------------------------------------------------------
globals:
  - id: led_mode
    type: int
    initial_value: '0'
    # 0 = user
    # 1 = ap_mode
    # 2 = wifi_feedback

  - id: prev_led_brightness
    type: float
    restore_value: no
    initial_value: '1.0'

  - id: led_clamp_active
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: power_accum
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: current_accum
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: voltage_accum
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: sample_count
    type: int
    restore_value: no
    initial_value: '0'

# --------------------------------------------------------------------
# PWM output
# --------------------------------------------------------------------
output:
  - platform: ledc
    pin: 6
    id: tablet_pwm
    frequency: 1000 Hz

# --------------------------------------------------------------------
# Charging switch
# --------------------------------------------------------------------
switch:
  - platform: template
    id: tablet_charging
    name: "Tablet Charging"
    optimistic: true

    on_turn_on:
      then:
        - lambda: |-
            // Apply clamp immediately if LED is already ON
            if (id(led_mode) != 0) return;
            if (!id(addressable_led).current_values.is_on()) return;

            float allowed = id(led_dim_level).state / 100.0f;
            float current = id(addressable_led).current_values.get_brightness();

            if (current > allowed + 0.01f) {
              id(prev_led_brightness) = current;
              id(led_clamp_active) = true;

              auto call = id(addressable_led).turn_on();
              call.set_brightness(allowed);
              call.perform();
            }

    on_turn_off:
      then:
        - lambda: |-
            if (!id(led_clamp_active)) return;

            if (id(addressable_led).current_values.is_on()) {
              auto call = id(addressable_led).turn_on();
              call.set_brightness(id(prev_led_brightness));
              call.perform();
            }

            id(led_clamp_active) = false;


# --------------------------------------------------------------------
# Addressable LED
# --------------------------------------------------------------------
light:
  - platform: esp32_rmt_led_strip
    id: addressable_led
    name: "LED"
    icon: mdi:television-ambient-light
    chipset: WS2812
    pin: GPIO5
    num_leds: 64
    rgb_order: GRB
    default_transition_length: 0s

    on_turn_on:
      then:
        - lambda: |-
            // System-owned LEDs must not be touched
            if (id(led_mode) != 0) return;

            // Only clamp when charging is active
            if (!id(tablet_charging).state) return;

            float allowed = id(led_dim_level).state / 100.0f;
            float current = id(addressable_led).current_values.get_brightness();

            // Clamp only if exceeding allowed brightness
            if (current > allowed + 0.01f) {

              // Save user intent ONCE
              if (!id(led_clamp_active)) {
                id(prev_led_brightness) = current;
                id(led_clamp_active) = true;
              }

              // Apply clamp (no transition)
              auto call = id(addressable_led).turn_on();
              call.set_brightness(allowed);
              call.perform();
            }

    effects:
      - addressable_rainbow:
          name: Rainbow
      - addressable_rainbow:
          name: Rainbow Fast
          speed: 10
      - addressable_color_wipe:
          name: Color Wipe
      - addressable_color_wipe:
          name: Color Wipe Reverse
          reverse: true
      - addressable_twinkle:
          name: Twinkle
          twinkle_probability: 5%
          progress_interval: 4ms
      - addressable_random_twinkle:
          name: Random Twinkle
      - addressable_scan:
          name: Scanner
          move_interval: 50ms
      - addressable_fireworks:
          name: Fireworks
          update_interval: 32ms
          spark_probability: 10%
          fade_out_rate: 120
      - addressable_flicker:
          name: Flicker
          intensity: 5%
      - pulse:
          name: Pulse
          transition_length: 1200ms
          update_interval: 1200ms  
      - pulse:
          name: Pulse Fast
          transition_length: 600ms
          update_interval: 600ms
      - random:
          name: Random Colors
      - addressable_color_wipe:
          name: Dual Color Wipe
          colors:
            - red: 100%
              green: 0%
              blue: 0%
              num_leds: 32
            - red: 0%
              green: 0%
              blue: 100%
              num_leds: 32
      - addressable_color_wipe:
          name: Soft White Sweep
          colors:
            - red: 100%
              green: 70%
              blue: 45%
              num_leds: 32
            - red: 20%
              green: 10%
              blue: 5%
              num_leds: 32
      - addressable_flicker:
          name: Candle Light
          intensity: 8%
      - addressable_fireworks:
          name: Fireplace
          update_interval: 64ms
          spark_probability: 3%
          fade_out_rate: 90
      - addressable_rainbow:
          name: Party Rainbow
          speed: 5
      - addressable_twinkle:
          name: Celebration Twinkle
          twinkle_probability: 15%
          progress_interval: 2ms
      - addressable_scan:
          name: Energy Beam
          move_interval: 20ms
      - addressable_random_twinkle:
          name: Galaxy
      - addressable_fireworks:
          name: Spark Storm
          update_interval: 16ms
          spark_probability: 20%
          fade_out_rate: 160

# --------------------------------------------------------------------
# LED system scripts
# --------------------------------------------------------------------
script:
  - id: led_ap_mode
    mode: restart
    then:
      - lambda: 'id(led_mode) = 1;'
      - light.turn_on:
          id: addressable_led
          effect: "Scanner"
          brightness: 100%
          red: 0%
          green: 0%
          blue: 100%

  - id: led_ap_mode_stop
    then:
      - if:
          condition:
            lambda: 'return id(led_mode) == 1;'
          then:
            - light.turn_off: addressable_led
            - lambda: 'id(led_mode) = 0;'

  - id: led_wifi_connected
    mode: restart
    then:
      - lambda: 'id(led_mode) = 2;'
      - light.turn_off: addressable_led
      - delay: 150ms
      - repeat:
          count: 3
          then:
            - light.turn_on:
                id: addressable_led
                brightness: 100%
                red: 0%
                green: 100%
                blue: 0%
            - delay: 250ms
            - light.turn_off: addressable_led
            - delay: 250ms
      - lambda: 'id(led_mode) = 0;'

# --------------------------------------------------------------------
# Sensors
# --------------------------------------------------------------------
sensor:
  - platform: ina219
    address: 0x40
    shunt_resistance: 0.1 ohm
    current:
      id: ina_current
      internal: true
    power:
      id: ina_power
      internal: true
    bus_voltage:
      id: ina_voltage
      internal: true
    update_interval: 1s

  - platform: internal_temperature
    id: esp32_internal_temp
    name: "ESP32 Internal Temp"
    update_interval: 15s

# --------------------------------------------------------------------
# Configuration numbers
# --------------------------------------------------------------------
number:
  - platform: template
    id: charging_limit_level
    name: "Charging Power"
    optimistic: true
    min_value: 30
    max_value: 100
    step: 2
    restore_value: true
    initial_value: 100

  - platform: template
    id: led_dim_level
    name: "Charging LED Dim Level"
    optimistic: true
    min_value: 50
    max_value: 100
    step: 1
    restore_value: true
    initial_value: 75

  - platform: template
    id: max_temp
    name: "Max ESP32 Temp"
    optimistic: true
    min_value: 70
    max_value: 100
    step: 1
    restore_value: true
    initial_value: 85

  - platform: template
    id: throttle_ratio
    name: "Thermal Throttle Ratio"
    optimistic: true
    min_value: 0.3
    max_value: 0.95
    step: 0.05
    restore_value: true
    initial_value: 0.9

# --------------------------------------------------------------------
# ðŸ§  Main logic â€” THERMAL / PWM ONLY (unchanged)
# --------------------------------------------------------------------
interval:
  - interval: 3s
    then:
      - lambda: |-
          float temp = id(esp32_internal_temp).state;
          bool charging_on = id(tablet_charging).state;

          static unsigned int burst_phase = 0;
          static bool cooling = false;

          float max_temp_val = id(max_temp).state;
          float limit_ratio = id(charging_limit_level).state / 100.0f;
          float throttle = id(throttle_ratio).state;
          float level = limit_ratio;

          if (!charging_on) {
            level = 0.0f;
          } else if (temp >= max_temp_val + 3.0f) {
            cooling = true;
          } else if (cooling && temp <= (max_temp_val - 3.0f)) {
            cooling = false;
          }

          if (charging_on && !cooling) {
            if (temp >= max_temp_val + 2.0f) {
              if (burst_phase < 3) level = throttle;
              burst_phase = (burst_phase + 1) % 4;
            } else if (temp >= max_temp_val) {
              if (burst_phase < 3) level = throttle;
              burst_phase = (burst_phase + 1) % 5;
            } else if (temp >= (max_temp_val - 3.0f)) {
              if (burst_phase < 2) level = throttle;
              burst_phase = (burst_phase + 1) % 5;
            } else {
              burst_phase = 0;
              level = limit_ratio;
            }
          }

          id(tablet_pwm).set_level(level);
