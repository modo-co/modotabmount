esphome:
  name: modotabmount
  friendly_name: Modo Tab Mount
  name_add_mac_suffix: true

  on_boot:
    - priority: 250.0
      then:
        - lambda: |-
            // Check if there are ANY credentials stored in the WiFi component
            if (wifi::global_wifi_component->get_sta().get_ssid().empty()) {
              ESP_LOGI("main", "Factory state detected: No WiFi credentials. Starting scanner.");
              id(led_ap_mode).execute();
            } else {
              ESP_LOGI("main", "Credentials found. Waiting for WiFi connection...");
            }

esp32:
  board: esp32-c3-devkitm-1
  variant: esp32c3
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP_TASK_WDT_TIMEOUT_S: "10"
  
logger:
  
debug:
  update_interval: 10s

network:
  enable_high_performance: true

mdns:
  id: my_mdns

api:

wifi:
  
  power_save_mode: none
  ap:
  on_connect:
    then:
      - logger.log: "WiFi connected"
      - script.execute: led_ap_mode_stop
      - script.execute: led_wifi_connected
      - lambda: |-
          id(my_mdns).setup();
          ESP_LOGI("custom", "mDNS re-initialized manually after WiFi connect");
           
captive_portal:

ota:
  - platform: esphome

web_server:
  port: 80
  version: 3
  log: false
  ota: false

esp32_ble:
  disable_bt_logs: true

bluetooth_proxy:
  id: bt_proxy
  active: false
  connection_slots: 1
  cache_services: false

i2c:
  sda: 7
  scl: 21
  scan: false

# --------------------------------------------------------------------
# Globals
# --------------------------------------------------------------------
globals: 
  - id: prev_led_brightness
    type: float
    restore_value: no
    initial_value: '1.0'

  - id: last_charging_state
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: power_accum
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: current_accum
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: voltage_accum
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: sample_count
    type: int
    restore_value: no
    initial_value: '0'

  # clamp state (replaces old "led_dimmed_by_charge" loop)
  - id: led_clamp_active
    type: bool
    restore_value: no
    initial_value: 'false'

  # ownership to prevent clamp touching AP/WiFi feedback
  - id: led_mode
    type: int
    restore_value: no
    initial_value: '0'
    # 0 = user
    # 1 = ap_mode
    # 2 = wifi_feedback

# --------------------------------------------------------------------
# PWM output
# --------------------------------------------------------------------
output:
  - platform: ledc
    pin: 6
    id: tablet_pwm
    frequency: 1000 Hz

# --------------------------------------------------------------------
# ⚡ Charging control
# --------------------------------------------------------------------
switch:

  - platform: template
    name: "Bluetooth Enabled"
    id: bluetooth_switch
    optimistic: true
    restore_mode: ALWAYS_ON
    entity_category: config
    icon: "mdi:bluetooth-off"

    # When turned off, disable the BLE radio
    on_turn_off:
      then:
        - ble.disable:
        - logger.log: "Bluetooth radio disabled"

    # When turned on, enable the BLE radio on boot
    on_turn_on:
      then:
        - logger.log: "Bluetooth radio enabled - reboot"
  
  - platform: template
    id: tablet_charging
    name: "Tablet Charging"
    icon: "mdi:tablet-cellphone"
    optimistic: true

    # apply clamp immediately if LED already on
    on_turn_on:
      then:
        - script.execute: led_apply_clamp_deferred

    # restore user brightness when charging turns off
    on_turn_off:
      then:
        - lambda: |-
            if (!id(led_clamp_active)) return;

            if (id(addressable_led).current_values.is_on()) {
              auto call = id(addressable_led).turn_on();
              call.set_brightness(id(prev_led_brightness));
              call.perform();
            }

            id(led_clamp_active) = false;
            
# --------------------------------------------------------------------
# Addressable LED
# --------------------------------------------------------------------
light:
  - platform: esp32_rmt_led_strip
    id: addressable_led
    name: "LED"
    icon: "mdi:television-ambient-light"
    chipset: WS2812
    pin: GPIO5
    num_leds: 64
    rgb_order: GRB
    default_transition_length: 0s

    on_state:
      then:
        - script.execute: led_apply_clamp_deferred

    effects:
      - addressable_rainbow:
          name: Rainbow
      - addressable_color_wipe:
          name: Color Wipe
      - addressable_twinkle:
          name: Twinkle
      - addressable_scan:
          name: Scanner
          move_interval: 50ms
      - pulse:
          name: Pulse
          transition_length: 1000ms
          update_interval: 1000ms
      - pulse:
          name: Pulse Fast
          transition_length: 500ms
          update_interval: 500ms
      - random:
          name: Random Colors
      - addressable_scan:
          name: Energy Beam
          move_interval: 20ms

# --------------------------------------------------------------------
# LED system scripts (AP + WiFi feedback + clamp)
# --------------------------------------------------------------------
script:
  - id: led_apply_clamp_deferred
    mode: restart
    then:
      - delay: 0ms
      - lambda: |-
          // Do not touch system-owned LED modes (AP / WiFi feedback)
          if (id(led_mode) != 0) return;

          // Clamp only while charging
          if (!id(tablet_charging).state) return;

          // LED must be ON
          if (!id(addressable_led).current_values.is_on()) return;

          float allowed = id(led_dim_level).state / 100.0f;
          float current = id(addressable_led).current_values.get_brightness();

          // User sets LOWER brightness while charging → accept it
          if (current < allowed - 0.01f) {
            id(prev_led_brightness) = current;
            id(led_clamp_active) = false;
            return;
          }

          // Already within limits → nothing to do
          if (current <= allowed + 0.01f) return;

          // Above allowed → clamp
          if (!id(led_clamp_active)) {
            id(prev_led_brightness) = current;
            id(led_clamp_active) = true;
          }

          auto call = id(addressable_led).turn_on();
          call.set_brightness(allowed);
          call.perform();


  - id: led_ap_mode
    mode: restart
    then:
      - lambda: 'id(led_mode) = 1;'
      - light.turn_on:
          id: addressable_led
          effect: "Scanner"
          brightness: 100%
          red: 0%
          green: 0%
          blue: 100%

  - id: led_ap_mode_stop
    then:
      - if:
          condition:
            lambda: 'return id(led_mode) == 1;'
          then:
            - light.turn_off: addressable_led
            - lambda: 'id(led_mode) = 0;'

  - id: led_wifi_connected
    mode: restart
    then:
      - lambda: 'id(led_mode) = 2;'
      - light.turn_off:
          id: addressable_led
          transition_length: 0s
      - delay: 150ms
      - repeat:
          count: 3
          then:
            - light.turn_on:
                id: addressable_led
                brightness: 100%
                red: 0%
                green: 100%
                blue: 0%
                transition_length: 0s
            - delay: 250ms
            - light.turn_off:
                id: addressable_led
                transition_length: 0s
            - delay: 250ms
      - lambda: 'id(led_mode) = 0;'

# --------------------------------------------------------------------
# Text sensors
# --------------------------------------------------------------------
text_sensor:
  - platform: template
    name: "Charging Status"
    id: charging_status
    icon: "mdi:lightning-bolt-outline"
    update_interval: never

  - platform: debug
    device:
      name: "Device Info"
      disabled_by_default: true
    reset_reason:
      name: "Device Reset Reason"

# --------------------------------------------------------------------
# Sensors
# --------------------------------------------------------------------
sensor:
  - platform: template
    name: "Bus Voltage"
    id: avg_voltage
    unit_of_measurement: "V"
    accuracy_decimals: 2
    icon: "mdi:flash"
    device_class: voltage
    state_class: measurement
    lambda: |-
      return 0.0;
    update_interval: never

  - platform: template
    name: "Bus Voltage Inst."
    id: voltage_act
    unit_of_measurement: "V"
    icon: "mdi:flash-triangle-outline"
    device_class: voltage
    state_class: measurement
    lambda: |-
      return 0.0;
    update_interval: never
    disabled_by_default: true

  - platform: template
    name: "Current"
    id: avg_current
    unit_of_measurement: "A"
    accuracy_decimals: 3
    icon: "mdi:current-ac"
    device_class: current
    state_class: measurement
    lambda: |-
      return 0.0;
    update_interval: never

  - platform: template
    name: "Output Current Inst."
    id: current_act
    unit_of_measurement: "A"
    icon: "mdi:current-dc"
    device_class: current
    state_class: measurement
    lambda: |-
      return 0.0;
    update_interval: never
    disabled_by_default: true

  - platform: template
    name: "Power"
    id: avg_power
    unit_of_measurement: "W"
    accuracy_decimals: 2
    icon: "mdi:lightning-bolt"
    device_class: power
    state_class: measurement
    lambda: |-
      return 0.0;
    update_interval: never

  - platform: template
    name: "Output Power Inst."
    id: power_act
    unit_of_measurement: "W"
    icon: "mdi:flash-alert-outline"
    device_class: power
    state_class: measurement
    lambda: |-
      return 0.0;
    update_interval: never
    disabled_by_default: true

  - platform: ina219
    address: 0x40
    shunt_resistance: 0.1 ohm
    current:
      id: ina_current
      internal: true
    power:
      id: ina_power
      internal: true
    bus_voltage:
      id: ina_voltage
      internal: true
    update_interval: 1s

  # --- Diagnostics ---
  - platform: internal_temperature
    name: "ESP32 Internal Temp"
    id: esp32_internal_temp
    update_interval: 15s
    icon: "mdi:thermometer-lines"
    entity_category: diagnostic

  - platform: uptime
    name: "Uptime"
    type: seconds
    icon: "mdi:clock-outline"
    entity_category: diagnostic

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    icon: "mdi:wifi"
    entity_category: diagnostic

  - platform: debug
    free:
      name: "Heap Free"
      icon: "mdi:memory"
      disabled_by_default: true
    block:
      name: "Heap Max Block"
      icon: "mdi:memory"
      disabled_by_default: true
    loop_time:
      name: "Loop Time"
      icon: "mdi:timer-outline"
      disabled_by_default: true

# --------------------------------------------------------------------
# ⚙️ Configuration
# --------------------------------------------------------------------
number:
  - platform: template
    name: "Charging Power"
    id: charging_limit_level
    optimistic: true
    min_value: 30
    max_value: 100
    step: 2
    restore_value: true
    initial_value: 100
    unit_of_measurement: "%"
    icon: "mdi:lightning-bolt"
    entity_category: config

  - platform: template
    name: "Max ESP32 Temp."
    id: max_temp
    optimistic: true
    restore_value: true
    min_value: 70
    max_value: 100
    step: 1
    initial_value: 85
    unit_of_measurement: "°C"
    icon: "mdi:thermometer"
    entity_category: config

  - platform: template
    name: "Thermal Throttle Ratio"
    id: throttle_ratio
    optimistic: true
    restore_value: true
    min_value: 0.3
    max_value: 0.95
    step: 0.05
    initial_value: 0.9
    unit_of_measurement: "ratio"
    icon: "mdi:flash-outline"
    entity_category: config

  - platform: template
    name: "Charging LED Dim Level"
    id: led_dim_level
    optimistic: true
    restore_value: true
    min_value: 50
    max_value: 100
    step: 1
    initial_value: 75
    unit_of_measurement: "%"
    icon: "mdi:brightness-6"
    entity_category: config

  - platform: template
    name: "Control Interval"
    id: control_interval
    optimistic: true
    restore_value: true
    min_value: 1
    max_value: 10
    step: 1
    initial_value: 1
    unit_of_measurement: "s"
    icon: "mdi:timer-outline"
    entity_category: config
    disabled_by_default: true

button:
  - platform: restart
    id: restart_button
    name: "Restart Device"
    icon: "mdi:restart"
    entity_category: config

# --------------------------------------------------------------------
# THERMAL + STATUS + AVERAGING
# --------------------------------------------------------------------
interval:
  - interval: 1s
    then:
      - lambda: |-
          static uint32_t last_run = 0;
          uint32_t now = millis();

          uint32_t interval_ms = (uint32_t)(id(control_interval).state * 1000.0f);

          if (now - last_run < interval_ms) return;
          last_run = now;

          // ------------------------------------------------------------------
          // EXISTING THERMAL + STATUS + AVERAGING LOGIC (unchanged)
          // ------------------------------------------------------------------

          float temp = id(esp32_internal_temp).state;
          bool charging_on = id(tablet_charging).state;

          static unsigned int burst_phase = 0;
          static bool cooling = false;

          float max_temp_val = id(max_temp).state;
          float limit_ratio = id(charging_limit_level).state / 100.0f;
          float throttle = id(throttle_ratio).state;
          float level = limit_ratio;

          const char* status = "Normal";

          if (!charging_on) {
            level = 0.0f;
            status = "Off";
          } else if (temp >= max_temp_val + 3.0f) {
            cooling = true;
            status = "Cooling Down";
          } else if (cooling && temp <= (max_temp_val - 3.0f)) {
            cooling = false;
          }

          if (charging_on && !cooling) {
            if (temp >= max_temp_val + 2.0f) {
              status = "Thermal throttling 3";
              if (burst_phase < 3) level = throttle;
              burst_phase = (burst_phase + 1) % 4;
            } else if (temp >= max_temp_val) {
              status = "Thermal throttling 2";
              if (burst_phase < 3) level = throttle;
              burst_phase = (burst_phase + 1) % 5;
            } else if (temp >= (max_temp_val - 3.0f)) {
              status = "Thermal throttling 1";
              if (burst_phase < 2) level = throttle;
              burst_phase = (burst_phase + 1) % 5;
            } else {
              status = "Normal";
              level = limit_ratio;
              burst_phase = 0;
            }
          }

          id(tablet_pwm).set_level(level);

          // Publish charging status ONLY when it changes
          static const char* last_status = "";
          if (strcmp(last_status, status) != 0) {
            id(charging_status).publish_state(status);
            last_status = status;
          }

          // 30s averaging (unchanged behavior)
          id(power_act).publish_state(id(ina_power).state);
          id(current_act).publish_state(id(ina_current).state);
          id(voltage_act).publish_state(id(ina_voltage).state);

          id(power_accum) += id(ina_power).state;
          id(current_accum) += id(ina_current).state;
          id(voltage_accum) += id(ina_voltage).state;
          id(sample_count)++;

          if (id(sample_count) >= 30) {
            id(avg_power).publish_state(id(power_accum) / id(sample_count));
            id(avg_current).publish_state(id(current_accum) / id(sample_count));
            id(avg_voltage).publish_state(id(voltage_accum) / id(sample_count));
            id(power_accum) = id(current_accum) = id(voltage_accum) = 0;
            id(sample_count) = 0;
          }
